name: Docker CI/CD

on:
  push:
    branches: [ main, dev ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    env:
      TAG: ${{ github.ref == 'refs/heads/main' && 'latest' || 'dev' }}
      ENVIRONMENT: ${{ github.ref == 'refs/heads/main' && 'production' || 'test' }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_HUB_USERNAME }}
        password: ${{ secrets.DOCKER_HUB_TOKEN }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: ${{ secrets.DOCKER_HUB_USERNAME }}/nginx-app:${{ env.TAG }}

    - name: Deploy to GCP VM
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.GCP_VM_IP }}
        username: ${{ secrets.GCP_VM_USERNAME }}
        key: ${{ secrets.GCP_SSH_PRIVATE_KEY }}
        script: |
          echo "ðŸš€ Starting deployment to $ENVIRONMENT..."

          if [[ "$ENVIRONMENT" == "production" ]]; then
            CONTAINER_NAME="nginx-app"
            ENV_PATH="/opt/app"
            USE_SSL=true
          else
            CONTAINER_NAME="nginx-app-test"
            ENV_PATH="/opt/app-test"
            USE_SSL=false
          fi

          PORT_MAPPING="80:80"

          echo "ðŸ“¦ Container: $CONTAINER_NAME"
          echo "ðŸ“‚ ENV Path: $ENV_PATH"
          echo "ðŸ³ Docker Tag: $TAG"

          # ì¤‘ë³µ ì»¨í…Œì´ë„ˆ ì •ë¦¬
          docker stop $CONTAINER_NAME || true
          docker rm $CONTAINER_NAME || true

          # ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸°
          docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/nginx-app:$TAG

          # .env íŒŒì¼ ì“°ê¸°
          sudo mkdir -p $ENV_PATH
          sudo bash -c "cat > $ENV_PATH/.env << EOL
          DATABASE_HOST=${{ secrets.DATABASE_HOST }}
          DATABASE_PORT=${{ secrets.DATABASE_PORT }}
          DATABASE_USER=${{ secrets.DATABASE_USER }}
          DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
          DATABASE_NAME=${{ secrets.DATABASE_NAME }}
          LOCAL=${{ secrets.LOCAL }}
          KAKAO_CLIENT_ID=${{ secrets.KAKAO_CLIENT_ID }}
          KAKAO_CALLBACK_URL=${{ secrets.KAKAO_CALLBACK_URL }}
          SITE_URL=${{ secrets.SITE_URL }}
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          OPENAI_URL=${{ secrets.OPENAI_URL }}
          LLM_MODEL=${{ secrets.LLM_MODEL }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          SERVER_PORT=${{ secrets.SERVER_PORT }}
          AES_KEY=${{ secrets.AES_KEY }}
          MYSQL_CA_PATH=/app/db-certs/server-ca.pem
          MYSQL_CERT_PATH=/app/db-certs/client-cert.pem
          MYSQL_KEY_PATH=/app/db-certs/client-key.pem
          EOL"

          # SSL ì¸ì¦ì„œ ë³µì‚¬ (í”„ë¡œë•ì…˜ì—ì„œë§Œ)
          if [ "$USE_SSL" = true ]; then
            sudo mkdir -p $ENV_PATH/ssl

            if sudo bash -c "cp /etc/letsencrypt/live/api.teachercan.com/fullchain.pem $ENV_PATH/ssl/ && cp /etc/letsencrypt/live/api.teachercan.com/privkey.pem $ENV_PATH/ssl/"; then

              sudo chmod 644 $ENV_PATH/ssl/fullchain.pem
              sudo chmod 600 $ENV_PATH/ssl/privkey.pem
              sudo chown $(whoami):$(whoami) $ENV_PATH/ssl/fullchain.pem
              sudo chown $(whoami):$(whoami) $ENV_PATH/ssl/privkey.pem

              echo "âœ… SSL certificates configured."
            else
              echo "âŒ ERROR: SSL certificates not found!"
              exit 1
            fi
          fi

          # ë„ì»¤ ì‹¤í–‰
          echo "ðŸš€ Starting Docker container..."
          docker run -d \
            --name $CONTAINER_NAME \
            -p $PORT_MAPPING \
            -p 443:443 \
            -v $ENV_PATH/.env:/.env:ro \
            -v $ENV_PATH/ssl:/etc/nginx/ssl:ro \
            -v /home/kor8240/db-certs:/app/db-certs:ro \
            --restart always \
            ${{ secrets.DOCKER_HUB_USERNAME }}/nginx-app:$TAG

          echo "ðŸ§¹ Cleaning up unused images..."
          docker image prune -a -f

          echo "âœ… Deployment complete!"
